# Billboard/Chordify web scraper

Scrape chords for billboard hot-100/top-200 songs.
Also includes several CSV files, including a [joint Billbaord/Chordify CSV](https://raw.githubusercontent.com/khiner/billboard-chordify-scraper/main/chordify_with_rn_200_1991-01-05_to_2022-10-01.csv) with roman numeral chord sequences for 6,400 songs (200 top-charting songs in the years 1991-2022).

Builds on [Beach Clark's work](https://github.com/bclark288/alternative-measures) for his and Claire Arthur's [Alternative Measures: A Musicologist Workbench for Popular Music](https://www.smc2019.uma.es/articles/S6/S6_05_SMC2019_paper.pdf).

See the following notebooks to get a better understanding of the data:
* [ExploreBillboardData](https://colab.research.google.com/github/khiner/billboard-chordify-scraper/blob/main/ExploreBillboardData.ipynb)
* [ExploreRomanNumerals](https://colab.research.google.com/github/khiner/billboard-chordify-scraper/blob/main/ExploreRomanNumerals.ipynb)

See the [AddRomanNumerals notebook](https://colab.research.google.com/github/khiner/billboard-chordify-scraper/blob/main/AddRomanNumerals.ipynb), which is used to add the roman numerals to the Billboard dataset.
The rest of the processing id done in actual (raw python) scripts, as documented below.

This is for a final group project for MUSI-8803: Computational Musicology at GA Tech, and includes work from myself, Brittney Allen, and Sile Yin.
See the [final presentation slides](https://docs.google.com/presentation/d/1RnGAaa67iWnUoTTuk1r8DKIj7NXP64Aj8sNEKNuZ6QE) for more details.

## Install and run

### Scrape Billboard

```shell
$ pip install -r requirements.txt
$ python billboard_scrape.py # Defaults to the range [1 year ago, most recent billboard week]
```

This will create a file `billboard.csv` file with a row per-song-per-week.
(Use the `-o`/`--output` argument to change the output file name.)

### Reduce Billboard to unique Top-N highest-charting songs per year

The script `billboard_reduce.py` transforms this CSV into a new one with the highest-charting N songs per-year.
N defaults to 100 and can be set with the `-n`/`--topn` argument.

"Highest-charting" here means: For each year, sort the rows (each row is a song in a weekly chart within the year) first by chart position,
and secondarily by its maximum consecutive weeks on the charts.
Finally, remove duplicate songs, keeping only the first occurrence of each song, corresponding to its highest/longest-charting week in its first charting year.

Run with:

```shell
$ python billboard_reduce.py billboard.csv
```

This will create a `billboard_reduced.csv` file with a row per-song-per-week.
(Use the `-o`/`--output` argument to change the output file name.)

### Scrape Chordify.net

Finally, to scrape the key and chords for every song in this reduced Billboard CSV (or top-N songs per year using the `-n`/`-topn` argument), run:

```
$ python chordify_scrape.py
```

This will create a `chordify.csv` file, with the same rows as the input CSV, but with new `key` and `chords` columns added.
(Use the `-o`/`--output` argument to change the output file name.)

### CSV output specification

#### `billboard_scrape` / `billboard_reduce`

The CSV file generated by `billboard_scrape.py` has a header row and a row per-song-per-week in the requested period.

`billboard_reduce.py` has the same schema, but fewer rows.

Here are the details for each column:

| Column name | Column type | Description                                                                                  |
|-------------|-------------|----------------------------------------------------------------------------------------------|
| date        | string      | Chart date for the entry (in "YYYY-mm-dd" format)                                            |
| artist      | string      | Artist name                                                                                  |
| song        | string      | Song name                                                                                    |
| pos         | int         | Position in this week's chart                                                                |
| pos_prev    | int         | Position of the song in the previous week's chart. 0 if it was not present in previous week. |
| pos_peak    | int         | Peak position of the song across all Billboard Hot-100 charts. Always present and non-0.     |
| weeks       | int         | Number of consecutive weeks on the charts                                                    |

#### `chordify_scrape`

`chordify_scrape.py` produced a CSV file with all of the above columns, with the addition columns:

| Column name | Column type          | Description                                    |
|-------------|----------------------|------------------------------------------------|
| key         | string               | The key of the song                            |
| chord       | JSON list of strings | An ordered list of all the chords in the song. |

### Options

Assuming the system time when running is within Sunday Oct 9, 2022.
Let's request a start-date, `2016-4-25` (which happens to be a Monday) and an explicit end-date of `2022-10-8` (yesterday, a Saturday).
The start and end dates will be rounded to the previous Saturday, which is what Billboard uses for their weekly chart end-date.
Since the requested end date is less than one week ago, results will be limited to the week ending the previous Saturday to ensure the Billboard chart is available:

```shell
$ python billboard_scrape.py --start="2016-4-25" --end="2022-10-8"
Requested dates: 2016-04-25 to 2022-10-08
Converted dates: 2016-04-23 to 2022-10-01
```

All option details:

#### `billboard_scrape`

```shell
$ python billboard_scrape.py --help
usage: billboard_scrape.py [-h] [-s START] [-e END] [-c CHART] [-o OUTPUT] [-v VERBOSE]

options:
  -h, --help            show this help message and exit
  -s START, --start START
                        Start date in YYYY-mm-dd format. Defaults to one year ago
  -e END, --end END     End date in YYYY-mm-dd format. Defaults to the most recent saturday with a Billboard chart.
  -c CHART, --chart CHART
                        Default to "100" for the "Hot-100" list. Other option is "200" for "Billboard-200".
  -o OUTPUT, --output OUTPUT
                        The name of the output CSV file (including the .csv suffix). Defaults to "billboard.csv".
  -v VERBOSE, --verbose VERBOSE
                        Verbose logging. Defaults to true.
```

#### `billboard_reduce`

```shell
$ python billboard_reduce.py --help
usage: billboard_reduce.py [-h] [-n TOPN] [-o OUTPUT] [-v VERBOSE] [billboard_csv]

positional arguments:
  billboard_csv         Path to input Billboard CSV file, as produced by `billboard_scrape.py`. Defaults to "billboard.csv".

options:
  -h, --help            show this help message and exit
  -n TOPN, --topn TOPN  The number of top-charting songs (unique across all years) to export for each year. Defaults to 100.
  -o OUTPUT, --output OUTPUT
                        The name of the output CSV file (including the .csv suffix). Defaults to "billboard_reduced.csv".
  -v VERBOSE, --verbose VERBOSE
                        Verbose logging. Defaults to true.
```

#### `chordify_scrape`

```shell
$ python chordify_scrape.py --help
usage: chordify_scrape.py [-h] [-o OUTPUT] [-n TOPN] [-m MINCHORDS] [-v VERBOSE] [billboard_csv]

positional arguments:
  billboard_csv         Path to input Billboard CSV file, as produced by `billboard_scrape.py` followed by `billboard_reduce.py`. Defaults to "billboard_reduced.csv".

options:
  -h, --help            show this help message and exit
  -o OUTPUT, --output OUTPUT
                        The name of the output CSV file (including the .csv suffix). Defaults to "chordify.csv".
  -n TOPN, --topn TOPN  The number of songs per year for which to scrape chords, starting at the first song for each year in the provided CSV. To scrape chords for all songs, just pass a number greater than or equal to the
                        max number of songs in any year. Defaults to 100.
  -m MINCHORDS, --minchords MINCHORDS
                        The minimum number of chord instances (not unique chord values!) a song must have in order to add to the dataset. A result with fewer chords than this limit will be skipped. If no results for a song
                        meet this chord limit, the "chords" column for the song will be NaN. Defaults to 8.
  -v VERBOSE, --verbose VERBOSE
                        Verbose logging. Defaults to true.
```
